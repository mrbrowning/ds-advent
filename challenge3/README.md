Misc Notes
==========

The general idea here is that we maintain a state machine for each neighbor (neighbors are the children and parent of this node as determined by constructing a simple spanning tree from the node_ids list) that tracks its health, what we're trying to send to it, and what we have sent to it (this is resilient to node partitions, but of course not at all to node failure as it's currently designed). If it's unhealthy we retry a broadcast until it comes back online, and then to speed up convergence send it our entire state when it comes back online. This got a little baroque with the last few rounds of tightening up msgs/op since I elected to build on top of what I had rather than rip it all out, but with the benefit of hindsight I'd take more advantage of the idempotency of the broadcast operation and fold the all-messages catchup into the multiple-valued ones we send to peers, and to do less fiddly bookkeeping. Still, it's successful at meeting the message-count and latency requirements.
