Transaction Challenge
=====================

The replication logic here is straightforward: filter reads from any transaction request we get and send those to all neighbors, retrying at a fixed interval until we hear back from them. This works fine, since read committed, among other laxities, imposes no ordering constraints over reads/writes outside of the prevention of dirty read/dirty write anomalies. To prevent dirty reads, we store each key alongside its version number, and atomically create a snapshot of the values and versions of each key referenced in a transaction on initialization of that transaction. That snapshotted version is incremented on write. On commit, if the stored version is greater than or equal to the version of a key we wrote in the transaction (this is guaranteed to indicate that another transaction that wrote to that key committed while this transaction was in progress, since each transaction only writes to a given key once) then the transaction is canceled and retried, otherwise the updated values are committed atomically.
