ds-advent
=========

A Rust client library for [Maelstrom](https://github.com/jepsen-io/maelstrom) and solutions for fly.io's set of [distributed systems challenges](https://fly.io/dist-sys/1/).

## About the Client Library

I thought it'd be an interesting, quick way to get my head in place to attempt a translation of fly.io's [Go client](https://pkg.go.dev/github.com/jepsen-io/maelstrom/demo/go) to Rust that maintained, as well as possible, the clear-box semantics of the Go library. That library is simple enough that a more idiomatic async implementation maintaining adherence to the Maelstrom protocol seems pretty straightforward -- CSP-style tasks owning resources like stdin/stdout that would otherwise be protected by locks (no tokio Mutex!) and communicating over channels, the Node equivalent handling only message ser/de and delegating behavior to a generic implementor, with that behavior being staticly dispatched instead of the dynamic handler registration of the Go lib -- so a superficially naive translation might make for a good learning experience.

I figured some of the things the Go library does might require some contortions to preserve -- the way handlers defined in the node's originating scope close over the node, for example, which was just much easier to solve by having my handlers take a reference to the node as an argument -- and indeed they did. To make the node `Send`, nearly every field has to be wrapped in a mutex, sometimes unfortunately Tokio mutexes in cases where not holding a lock over an await point would require a significant redesign, at which point why not just abandon this mercurial project and do it the idiomatic way; handlers need to be able to call async methods on the node, so without async closures they return a `BoxedFuture` to tie their return value's lifetime to the node's and allow the handler's calling context to await their result; `Send + Sync + 'static` bounds are everywhere.

On the plus side, this implementation does add at least a little type safety -- uninitialized vs. initialized nodes are represented via typestates that prevent incoherent actions like initializing an initialized node or sending a message from a node with no ID, and reply callbacks implement `FnOnce`. This also means that the semantics in the small of the Go library aren't precisely preserved, since that library will happily handle an init message to an initialized node, but it's compliant with the contract expected by Maelstrom.
